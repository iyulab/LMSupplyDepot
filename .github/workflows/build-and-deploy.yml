name: Build and Deploy

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Security and quality checks
  security-scan:
    runs-on: ubuntu-latest
    name: Security Scan
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Restore dependencies
      run: dotnet restore src/LMSupplyDepots.sln

    - name: Run security scan
      run: |
        echo "üõ°Ô∏è Running security scan..."
        dotnet list src/LMSupplyDepots.sln package --vulnerable --include-transitive
        if [ $? -ne 0 ]; then
          echo "üö® Security vulnerabilities detected!"
          exit 1
        fi

    - name: Run code analysis
      run: |
        dotnet build src/LMSupplyDepots.sln -c Release --no-restore -p:TreatWarningsAsErrors=true

  # Build and test
  build-and-test:
    runs-on: ubuntu-latest
    needs: security-scan
    strategy:
      matrix:
        configuration: [Release]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', 'Directory.Packages.props') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore src/LMSupplyDepots.sln

    - name: Build solution
      run: dotnet build src/LMSupplyDepots.sln -c ${{ matrix.configuration }} --no-restore

    - name: Run CI tests
      run: |
        dotnet test src/LMSupplyDepots.sln -c ${{ matrix.configuration }} --no-build \
          --logger "trx;LogFileName=test-results.trx" \
          --logger "console;verbosity=normal" \
          --collect:"XPlat Code Coverage" \
          --results-directory TestResults \
          --filter "Category!=RequiresModel&Category!=RequiresApiKey&Category!=RequiresNetwork&Category!=RequiresLargeMemory&Category!=RequiresGpu&Category!=LocalOnly"

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.configuration }}
        path: |
          TestResults/*.trx
          TestResults/*/coverage.cobertura.xml
        retention-days: 30

    - name: Publish test results
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: Test Results (${{ matrix.configuration }})
        path: 'TestResults/*.trx'
        reporter: dotnet-trx
        fail-on-error: true

  # Build Docker images
  build-images:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.event_name != 'pull_request'
    outputs:
      hostapp-image: ${{ steps.meta-hostapp.outputs.tags }}
      cli-image: ${{ steps.meta-cli.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # Build HostApp image
    - name: Extract metadata (HostApp)
      id: meta-hostapp
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/hostapp
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,format=short

    - name: Build and push HostApp image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: docker/Dockerfile.hostapp
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta-hostapp.outputs.tags }}
        labels: ${{ steps.meta-hostapp.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    # Build CLI image
    - name: Extract metadata (CLI)
      id: meta-cli
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/cli
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,format=short

    - name: Build and push CLI image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: docker/Dockerfile.cli
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta-cli.outputs.tags }}
        labels: ${{ steps.meta-cli.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Deploy to staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: build-images
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to staging
      run: |
        echo "üöÄ Deploying to staging environment..."
        echo "HostApp Image: ${{ needs.build-images.outputs.hostapp-image }}"
        echo "CLI Image: ${{ needs.build-images.outputs.cli-image }}"

        # In a real environment, this would deploy to staging infrastructure
        # For example, using kubectl, docker-compose, or cloud-specific tools

        # Example with docker-compose (would run on staging server):
        # export HOSTAPP_IMAGE="${{ needs.build-images.outputs.hostapp-image }}"
        # export CLI_IMAGE="${{ needs.build-images.outputs.cli-image }}"
        # docker-compose -f docker-compose.prod.yml up -d

  # Deploy to production
  deploy-production:
    runs-on: ubuntu-latest
    needs: build-images
    if: startsWith(github.ref, 'refs/tags/v')
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to production
      run: |
        echo "üéâ Deploying to production environment..."
        echo "HostApp Image: ${{ needs.build-images.outputs.hostapp-image }}"
        echo "CLI Image: ${{ needs.build-images.outputs.cli-image }}"

        # Production deployment logic would go here
        # This might include:
        # - Blue/green deployment
        # - Rolling updates
        # - Health checks
        # - Rollback procedures

  # Create GitHub release for tags
  create-release:
    runs-on: ubuntu-latest
    needs: [build-images, deploy-production]
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        body: |
          ## LMSupplyDepots Release ${{ github.ref }}

          ### Docker Images
          - **HostApp**: `${{ needs.build-images.outputs.hostapp-image }}`
          - **CLI**: `${{ needs.build-images.outputs.cli-image }}`

          ### Changes
          See [CHANGELOG.md](./CHANGELOG.md) for details.

          ### Deployment
          This release has been automatically deployed to production.
        draft: false
        prerelease: false